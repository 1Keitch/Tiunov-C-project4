#include <iostream>

template <typename T>
void my_swap(T num1, T num2) {
	T tmp = num1;
	num1;

	}
template <typename T>
void p_swap(T*pnum1, T* pnum2) {
	T tmp = *pnum1;
	*pnum1 = *pnum2;
	*pnum2 = tmp;

}

//  Модуль 6 - указатели
//  Указатель - переменная, созданная для хранения в себе адреса какой - либо области памяти. 
//  Например указатель может хранить адрес созданной ранее в программе переменной
//  pointer - указатель 

int main() {
	setlocale(LC_ALL, "Russian");
	int n,m; // переменная 

	// Указатели на переменные.
	/*
	n = 10; m = 20;
	std::cout << "n= " << n << std::endl;// вывод значение переменное 
	std::cout << "&n= " << &n << std::endl;// вывод адреса переменной
	int* pn= &n; // создание указателя, направленнного на переменную n
	std::cout << "pn =" << pn << std::endl; // записали указатель 
	std::cout << "*pn= " << *pn << std::endl;
	// делаем разысенование указателя 
	*pn = 15;
	std::cout << "Новая n = " << n << std::endl;
	// разыменование - указателя 
	// операция применяймая только к указателям, и позволяющая обратиться к объекту на который направлен указатель
	pn = &m; // перенаправление указателя на переменную n
	std::cout << "&m= " << &m << std::endl;
	std::cout << "pn= " << pn << std::endl;

	int* pm = &m;
	std::cout <<"pm = "  << pm << std::endl;
	*pm = 25;
    std:: cout << "m = " << m << std::endl;
    std::cout << "*pn = " << *pn << std::endl;
    std::cout << "*pm = " << *pm << std::endl;
	*/

	// Указатели в массивах
	
	/*
	const int size = 5;
	int arr[size]{ 10, 13, 5, 9, 54 };
	int* pa2 = &arr[2];
	std::cout << "*pa2= " << *pa2 << std::endl; //5
	pa2++;
	std::cout << "*pa2= " << *pa2 << std::endl; //9
	pa2-= 2;
	std::cout << "*pa2= " << *pa2 << std::endl; //13
	pa2 = &arr[0];
	for (int i = 0; i < size; i++)
		std::cout << *( pa2 + i )  << ' ';
	std::cout << std::endl;

	std::cout << "arr= " << arr << std::endl;

	std::cout << "pa2= " << pa2 << std::endl;


	// Арифметика указателей -- процесс сдвига указателей относительно их текущего значения вперёд или назад в зависимости от применяймого к ним сложения или вычитание соотвесвенно 
	// Ограничение арифметики указателей 
	//1. Работает ТОЛЬКО со сложением и вычитанием
	//2. Нельзя складывать адрес но можно вычитать адреса
	//3. Нельхя работать с вещественными данным типом. (сложыть с вещественным или отрицательным не получится (только целые значение).
	
	//Имя массива - указатель на его первый элемент, или же указатель на место в памяти из которой начинается последовательносмть элементов.
	//Данный указатель не может быть направлен на другую область памяти.
	int sum = 0;
	for (int i = 0; i < size; i++)
		sum += *(arr + i);
	std::cout << "Сумма: " << sum << std::endl;
	arr = &n;
	*/

	// Указатели и функции

	n = 7; m = 15;
	std::cout << n << ' ' << m << std::endl;
    // my_swap(n, m);  
	// параметры копии аргументов
	p_swap(&n, &m);
	std::cout << n << " " << m << std::endl;

		return 0;


}








